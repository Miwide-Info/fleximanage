require('dotenv').config();
// flexiWAN SD-WAN software - flexiEdge, flexiManage.
// For more information go to https://flexiwan.com
// Copyright (C) 2020  flexiWAN Ltd.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, e    );

    console.log('=== CONFIGURING OPENAPI VALIDATOR ===');
    this.app.use(
      OpenApiValidator.middleware({
        apiSpec: this.openApiPath,
        validateRequests: configs.get('validateOpenAPIRequest', 'boolean'),
        validateResponses: configs.get('validateOpenAPIResponse', 'boolean')
      })
    );

    console.log('=== REGISTERING OPENAPI ROUTER ===');
    this.app.use(openapiRouter(this.schema.components.schemas));on 3 of the
// License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

const { version } = require('./package.json');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const configs = require('./configs')();
const swaggerUI = require('swagger-ui-express');
const yamljs = require('yamljs');
const express = require('express');
const cors = require('./routes/cors');
const cookieParser = require('cookie-parser');
const bodyParser = require('body-parser');
const OpenApiValidator = require('express-openapi-validator');
const openapiRouter = require('./utils/openapiRouter');
const createError = require('http-errors');
// const session = require('express-session');
const passport = require('passport');
const auth = require('./authenticate');
const { connectRouter } = require('./routes/connect');
const morgan = require('morgan');
const logger = require('./logging/logging')({ module: module.filename, type: 'req' });
const { reqLogger, errLogger } = require('./logging/request-logging');
const serialize = require('serialize-javascript');

// periodic tasks
const deviceStatus = require('./periodic/deviceStatus')();
const deviceQueues = require('./periodic/deviceQueue')();
const deviceSwVersion = require('./periodic/deviceSwVersion')();
const deviceSwUpgrade = require('./periodic/deviceperiodicUpgrade')();
const notifyUsers = require('./periodic/notifyUsers')();
const releasePendingTunnels = require('./periodic/releasePendingTunnels')();
const appRules = require('./periodic/appRules')();
const applications = require('./periodic/applications')();
const statusesInDb = require('./periodic/statusesInDb')();

require('./applicationLogic/initializeApps');

// rate limiter
const rateLimit = require('express-rate-limit');
const RateLimitStore = require('./rateLimitStore');

// Internal routers definition
const adminRouter = require('./routes/admin');
const ticketsRouter = require('./routes/tickets')(
  configs.get('ticketingSystemUsername', 'string'),
  configs.get('ticketingSystemToken', 'string'),
  configs.get('ticketingSystemUrl', 'string'),
  configs.get('ticketingSystemAccountId', 'string')
);

// WSS
const WebSocket = require('ws');
const connections = require('./websocket/Connections')();
const broker = require('./broker/broker.js');
const roleSelector = require('./utils/roleSelector')(configs.get('redisUrl'));

class ExpressServer {
  constructor (port, securePort, openApiYaml) {
    console.log('=== EXPRESS SERVER CONSTRUCTOR STARTED ===');
    this.port = port;
    this.securePort = securePort;
    this.app = express();
    this.openApiPath = openApiYaml;
    this.schema = yamljs.load(openApiYaml);
    const restServerUrl = configs.get('restServerUrl', 'list');
    const servers = this.schema.servers.filter(server => server.url.includes(restServerUrl));
    if (servers.length === 0) {
      this.schema.servers.unshift(...restServerUrl.map((restServer, idx) => {
        return {
          description: `Local Server #${idx + 1}`,
          url: restServer + '/api'
        };
      }));
    };

    this.setupMiddleware = this.setupMiddleware.bind(this);
    this.addErrorHandler = this.addErrorHandler.bind(this);
    this.onError = this.onError.bind(this);
    this.onListening = this.onListening.bind(this);
    this.launch = this.launch.bind(this);
    this.close = this.close.bind(this);
    this.httpsEnabled = false; // will flip true only if certs loaded & server created

    console.log('=== ABOUT TO CALL SETUP MIDDLEWARE ===');
    try {
      this.setupMiddleware();
      console.log('=== SETUP MIDDLEWARE COMPLETED ===');
    } catch (error) {
      console.error('=== SETUP MIDDLEWARE ERROR ===', error);
    }
  }

  setupMiddleware () {
    console.log('=== SETUP MIDDLEWARE STARTED ===');
    // this.setupAllowedMedia();
    // this.app.use((req, res, next) => {
    //   console.log(`${req.method}: ${req.url}`);
    //   return next();
    // });

    // A middleware that adds a unique request ID for each request
    // or uses the existing request ID, if there is one.
    // THIS MIDDLEWARE MUST BE ASSIGNED FIRST.
    // this.app.use((req, res, next) => {
    //   // Add unique ID to each request
    //   req.id = req.get('X-Request-Id') || uuid();
    //   res.set('X-Request-Id', req.id);

    //   // Set the remote address IP on the request
    //   req.ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    //   next();
    // });

    // Performance optimizations - add compression and caching
    const compressionMiddleware = require('./middleware/compression');
    const { createCacheMiddleware } = require('./middleware/cache');
    
    // Enable gzip compression for all responses
    this.app.use(compressionMiddleware);

    // Request logging middleware - must be defined before routers.
    this.app.use(reqLogger);
    this.app.set('trust proxy', true); // Needed to get the public IP if behind a proxy

    // Don't expose system internals in response headers
    this.app.disable('x-powered-by');

    // Use morgan request logger in development mode
    if (configs.get('environment') === 'development') this.app.use(morgan('dev'));

    // Initialize websocket traffic handler role selector
    // On every new websocket connection it will try to set itself as active
    roleSelector.initializeSelector('websocketHandler');

    // Start periodic device tasks
    deviceStatus.start();
    deviceQueues.start();
    deviceSwVersion.start();
    deviceSwUpgrade.start();
    notifyUsers.start();
    appRules.start();
    applications.start();
    statusesInDb.start();
    releasePendingTunnels.start();

    // Domain redirect: redirect local.miwide.com to manage.miwide.com
    this.app.all('*', (req, res, next) => {
      if (req.hostname === 'local.miwide.com') {
        const protocol = req.secure ? 'https' : 'http';
        const port = req.secure ? ':3443' : ':3000';
        return res.redirect(307, `${protocol}://manage.miwide.com${port}${req.url}`);
      }
      return next();
    });

    // HTTPS redirect only if configured AND https server actually initialized
    this.app.all('*', (req, res, next) => {
      const redirectDesired = configs.get('shouldRedirectHttps', 'boolean');
      // Exemptions:
      // 1. Preflight OPTIONS requests
      // 2. API calls (URLs starting with /api/) — avoid redirect loops / interruptions when axios/fetch faces 307 across schemes
      if (req.method === 'OPTIONS' || req.url.startsWith('/api/')) return next();
      if (!redirectDesired || !this.httpsEnabled || req.secure || req.url.startsWith('/.well-known/acme-challenge')) {
        return next();
      }
      return res.redirect(307, 'https://' + req.hostname + ':' + configs.get('redirectHttpsPort') + req.url);
    });

    // Global rate limiter to protect against DoS attacks
    // Windows size of 5 minutes
    const inMemoryStore = new RateLimitStore(5 * 60 * 1000);
    const rateLimiter = rateLimit({
      store: inMemoryStore,
      // Rate limit for requests in 5 min per IP address
      max: configs.get('userIpReqRateLimit', 'number'),
      message: { error: 'Request rate limit exceeded' },
      onLimitReached: (req, res, options) => {
        logger.error(
          'Request rate limit exceeded. blocking request', {
            params: { ip: req.ip },
            req: req
          });
      }
    });
    this.app.use(rateLimiter);

    // General settings here
    this.app.use(cors.cors);
    this.app.use(bodyParser.json());
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: false }));
    this.app.use(cookieParser());

    // Explicit JSON parse error handler (must appear after body parsers, before routes)
    // Without this, malformed JSON produces a generic 400 without our contextual log,
    // making it hard to distinguish from other pre-route 400 causes.
    this.app.use((err, req, res, next) => {
      if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        logger.warn('JSON parse error', { params: { message: err.message }, req });
        return res.status(400).json({ error: 'Invalid JSON payload' });
      }
      next(err);
    });

    // Routes allowed without authentication
    this.app.get('/', (req, res) => this.sendIndexFile(req, res));
    const staticDirSetting = configs.get('clientStaticDir');
    const staticPath = path.join(__dirname, staticDirSetting);
    if (fs.existsSync(staticPath)) {
      logger.info('Serving static UI directory', { params: { staticPath, configured: staticDirSetting } });
      this.app.use(express.static(staticPath));
    } else {
      // Provide actionable hints to operator
      const hints = [];
      hints.push('Build not found at expected path: ' + staticPath);
      hints.push('To generate it run: (cd frontend && npm install && npm run build)');
      if (!staticDirSetting.includes('frontend')) {
        hints.push('Currently configured clientStaticDir="' + staticDirSetting + '"');
        hints.push('If you intended to use the new React UI, ensure clientStaticDir points to ../frontend/build');
      }
      logger.warn('Static UI directory not found; skipping React build serving', { params: { staticPath, configured: staticDirSetting, hints } });
    }

    // Explicit favicon handler to avoid noisy "Route not found" logs when browser auto-requests it
    this.app.get('/favicon.ico', (req, res) => {
      // If you later add an actual favicon file, you can serve it here instead of a 204.
      res.status(204).end();
    });

    this.app.all('*', (req, res, next) => {
      const redirectDesired = configs.get('shouldRedirectHttps', 'boolean');
      if (req.method === 'OPTIONS' || req.url.startsWith('/api/')) return next();
      if (!redirectDesired || !this.httpsEnabled || req.secure || req.url.startsWith('/.well-known/acme-challenge')) {
        return next();
      }
      return res.redirect(307, 'https://' + req.hostname + ':' + configs.get('redirectHttpsPort') + req.url);
    });

    // no authentication
    this.app.use('/api/connect', connectRouter);
    this.app.use('/api/users', require('./routes/users'));
    // Admin audit log (super admin only) – placed early so swagger auth headers processed later
    this.app.use('/api/users/admin/audit', require('./routes/adminAudit'));

    // add API documentation
    this.app.use('/api-docs', swaggerUI.serve, swaggerUI.setup(this.schema));

    // initialize passport and authentication
    this.app.use(passport.initialize());

    // Enable db admin only in development mode
    if (configs.get('environment') === 'development') {
      logger.warn('Warning: Enabling UI database access');
      // mongo database UI
      try {
        const mongoExpress = require('mongo-express/lib/middleware');
        const mongoExpressConfig = require('./mongo_express_config');
        const expressApp = await mongoExpress(mongoExpressConfig);
        this.app.use('/admindb', expressApp);
      } catch (err) {
        logger.warn('mongo-express not available, skipping DB admin UI', { params: { error: err.message } });
      }
    }

    // Enable routes for non-authorized links
    this.app.use('/ok', express.static(path.join(__dirname, 'public', 'ok.html')));
    this.app.use('/spec', express.static(path.join(__dirname, 'api', 'openapi.yaml')));
    this.app.get('/hello', (req, res) => res.send('Hello World'));

    this.app.get('/api/version', (req, res) => res.json({ version }));
    this.app.get('/api/restServers', (req, res) => res.json({ version }));
    
    // Health check endpoint for Docker
    this.app.get('/api/health', (req, res) => {
      res.status(200).json({ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        version: version 
      });
    });

    // Public runtime configuration endpoint (no auth) – exposes only safe, non-secret fields
    // Allows frontend (e.g. Login page) to fetch captchaSiteKey at runtime without rebuild.
    this.app.get('/api/public/config', (req, res) => {
      try {
        // Expose whether backend will actually enforce captcha verification.
        // Backend verifies only when captchaKey (secret) is non-empty. Frontend can use this
        // to decide if absence/failure of widget should block login or just warn.
        const captchaSecretConfigured = !!configs.get('captchaKey');
        res.json({
          captchaSiteKey: configs.get('captchaSiteKey'),
          captchaEnforced: captchaSecretConfigured,
          companyName: configs.get('companyName'),
          allowUsersRegistration: configs.get('allowUsersRegistration', 'boolean')
        });
      } catch (e) {
        logger.error('Failed to serve public config', { params: { message: e.message }, req });
        res.status(500).json({ error: 'Public config unavailable' });
      }
    });

    // Public meta data (static enums / roles) for frontend dynamic rendering - with caching
    this.app.get('/api/public/meta', createCacheMiddleware({ customTTL: 'long' }), (req, res) => {
      try {
        const { SERVICE_TYPES } = require('./constants/serviceTypes');
        const { preDefinedPermissions } = require('./models/membership');
        // Only expose the keys of preDefinedPermissions (not the raw bitmasks per resource)
        const permissionPresets = Object.keys(preDefinedPermissions);
        
        // Add cache headers for this static data
        res.set({
          'Cache-Control': 'public, max-age=3600', // 1 hour
          'ETag': `"meta-${Date.now()}"`
        });
        
        res.json({ serviceTypes: SERVICE_TYPES, permissionPresets });
      } catch (e) {
        logger.error('Failed to serve public meta', { params: { message: e.message }, req });
        res.status(500).json({ error: 'Public meta unavailable' });
      }
    });

    // Add performance monitoring routes before authentication (public access)
    this.app.use('/api/performance', require('./routes/performance'));

    this.app.use(cors.corsWithOptions);
    this.app.use(auth.verifyUserJWT);
    // this.app.use(auth.verifyPermission);

    try {
      // FIXME: temporary map the OLD routes
      // this.app.use('/api/devices', require('./routes/devices'));
      // this.app.use('/api/devicestats', require('./routes/deviceStats'));
      // this.app.use('/api/jobs', require('./routes/deviceQueue'));
      this.app.use('/api/portals', require('./routes/portals'));
    } catch (error) {
      logger.error('Error: Can\'t connect OLD routes');
    }

    // Initialize authenticated routes
    this.app.use('/api/admin', adminRouter);
    this.app.use('/api/tickets', ticketsRouter);

    // reserved for future use
    // this.app.get('/login-redirect', (req, res) => {
    //   res.status(200);
    //   res.json(req.query);
    // });
    // this.app.get('/oauth2-redirect.html', (req, res) => {
    //   res.status(200);
    //   res.json(req.query);
    // });

    this.app.use(
      OpenApiValidator.middleware({
        apiSpec: this.openApiPath,
        validateRequests: configs.get('validateOpenAPIRequest', 'boolean'),
        validateResponses: configs.get('validateOpenAPIResponse', 'boolean')
      })
    );

    console.log('=== REGISTERING OPENAPI ROUTER ===');
    this.app.use(openapiRouter(this.schema.components.schemas));
    console.log('OpenAPI router registered, now registering dashboard...');
    
    // Dashboard routes - Register after OpenAPI router to avoid 404 issues
    console.log('Registering dashboard routes...');
    this.app.use('/api/dashboard', require('./routes/dashboard-clean'));
    console.log('Dashboard routes registered successfully');
  }

  sendIndexFile (req, res) {
    // get client config based on request object
    const clientConfig = configs.getClientConfig(req);

    const transformIndex = (origIndex) => {
      let modifiedIndex = configs.get('removeBranding', 'boolean')
        ? origIndex.replace('<title>flexiWAN Management</title>',
          `<title>${configs.get('companyName')} Management</title>`)
        : origIndex;
      const m = modifiedIndex.match(/const __FLEXIWAN_SERVER_CONFIG__=(.*?);/);
      if (m instanceof Array && m.length > 0) { // successful match
        // eslint-disable-next-line no-eval
        const newConfig = eval('(' + m[1] + ')');
        // Update default config with backend variables
        for (const c in clientConfig) {
          newConfig[c] = clientConfig[c];
        }
        modifiedIndex = modifiedIndex.replace(m[0],
          'const __FLEXIWAN_SERVER_CONFIG__=' + serialize(newConfig, { isJSON: true }) + ';');
      }
      return modifiedIndex;
    };

    const indexFile =
        fs.readFileSync(path.join(__dirname, configs.get('clientStaticDir'), 'index.html'));
    const transformedIndex = transformIndex(indexFile.toString());
    res.send(transformedIndex);
  }

  addErrorHandler () {
    // "catchall" handler, for any request that doesn't match one above, send back index.html file.
    this.app.get('*', (req, res, next) => {
      logger.info('Route not found', { req: req });
      this.sendIndexFile(req, res);
    });

    // catch 404 and forward to error handler
    this.app.use(function (req, res, next) {
      next(createError(404));
    });

    // Request error logger - must be defined after all routers
    // Set log severity on the request to log errors only for 5xx status codes.
    this.app.use((err, req, res, next) => {
      req.logSeverity = err.status || 500;
      next(err);
    });
    this.app.use(errLogger);

    /**
     * suppressed eslint rule: The next variable is required here, even though it's not used.
     *
     ** */
    // eslint-disable-next-line no-unused-vars
    this.app.use((error, req, res, next) => {
      const errorResponse = error.error || error.message || error.errors || 'Unknown error';
      res.status(error.status || 500);
      res.type('json');
      res.json({ error: errorResponse });
    });
  }

  /**
   * Event listener for HTTP/HTTPS server "error" event.
   */
  onError (port) {
    return function (error) {
      if (error.syscall !== 'listen') {
        throw error;
      }

      const bind = 'Port ' + port;

      // handle specific listen errors with friendly messages
      /* eslint-disable no-unreachable */
      switch (error.code) {
        case 'EACCES':
          console.error(bind + ' requires elevated privileges');
          process.exit(1);
          break;
        case 'EADDRINUSE':
          console.error(bind + ' is already in use');
          process.exit(1);
          break;
        default:
          throw error;
      }
    };
  }

  /**
  * Event listener for HTTP server "listening" event.
  */
  onListening (server) {
    return function () {
      const addr = server.address();
      const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
      console.debug('Listening on ' + bind);
    };
  }

  async launch () {
    this.addErrorHandler();

    try {
      this.server = http.createServer(this.app);

      if (configs.get('shouldRedirectHttps', 'boolean')) {
        const keyPath = path.join(__dirname, 'bin', configs.get('httpsCertKey'));
        const certPath = path.join(__dirname, 'bin', configs.get('httpsCert'));
        console.log('[HTTPS] Enabling HTTPS. Key:', keyPath, 'Cert:', certPath);
        try {
          this.options = {
            key: fs.readFileSync(keyPath),
            cert: fs.readFileSync(certPath)
          };
          this.secureServer = https.createServer(this.options, this.app);
          this.httpsEnabled = true;
        } catch (certErr) {
          console.error('[HTTPS] Failed to load certificate files', { message: certErr.message });
          // Fallback: continue with HTTP only rather than crashing whole process
        }
      }

      // setup wss here
      // Previous logic selected secureServer purely based on the config flag. If the flag was true
      // but certificate loading failed (leaving secureServer undefined), WebSocket.Server received
      // an options object without a valid 'server' / 'port' / 'noServer' property and threw:
      //   "One of the \"port\", \"server\", or \"noServer\" options must be specified"
      // We now only choose the secure server if it actually exists (httpsEnabled=true), otherwise
      // we transparently fall back to the HTTP server.
      const wantHttps = configs.get('shouldRedirectHttps', 'boolean');
      const wsUnderlyingServer = (wantHttps && this.httpsEnabled) ? this.secureServer : this.server;
      if (wantHttps && !this.httpsEnabled) {
        console.warn('[HTTPS] WebSocket fallback: HTTPS requested but secure server not initialized (cert load failed). Using HTTP server for WS.');
      }
      this.wss = new WebSocket.Server({
        server: wsUnderlyingServer,
        verifyClient: connections.verifyDevice
      });

      connections.registerConnectCallback('broker', broker.deviceConnectionOpened);
      connections.registerCloseCallback('broker', broker.deviceConnectionClosed);
      connections.registerCloseCallback('deviceStatus', deviceStatus.deviceConnectionClosed);

      this.wss.on('connection', connections.createConnection);
      console.log('Websocket server running');

      this.server.listen(this.port, () => {
        console.log('HTTP server listening on port', { params: { port: this.port } });
      });
      this.server.on('error', this.onError(this.port));
      this.server.on('listening', this.onListening(this.server));

      if (configs.get('shouldRedirectHttps', 'boolean')) {
        if (this.secureServer) {
          this.secureServer.listen(this.securePort, () => {
            console.log('HTTPS server listening on port', { params: { port: this.securePort } });
          });
          this.secureServer.on('error', this.onError(this.securePort));
          this.secureServer.on('listening', this.onListening(this.secureServer));
        } else {
          console.warn('[HTTPS] shouldRedirectHttps=true but secureServer not initialized ' +
            '- cert load failed. HTTP only.');
        }
      }
    } catch (error) {
      console.log('Express server lunch error', { params: { message: error.message } });
    }
  }

  async close () {
    if (this.server !== undefined) {
      await this.server.close();
      console.log(`HTTP Server on port ${this.port} shut down`);
    }
    if (this.secureServer !== undefined) {
      await this.secureServer.close();
      console.log(`HTTPS Server on port ${this.securePort} shut down`);
    }
  }
}

module.exports = ExpressServer;
